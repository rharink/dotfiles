#+title: Doom Emacs Configuration
#+author: rharink
#+startup: fold
#+property: header-args:emacs-lisp :tangle yes :cache yes :results silent :comments link
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent
#+html_head: <link rel='shortcut icon' type='image/png' href='https://www.gnu.org/software/emacs/favicon.png'>

* Custom functions
** Custom
#+begin_src emacs-lisp
(defun rh/send-notification (title msg)
  (interactive)
  (let ((notifier-path (executable-find "alerter")))
    (start-process
     "Appointment alert"
     "*Appointment alert*"
     notifier-path
     "-message" msg
     "-title" title
     "-sender" "org.gnu.Emacs"
     "-activate" "org.gnu.Emacs")))

(defun rh/appt-display-native (min-to-app new-time msg)
  (rh/send-notification
   (format "Appointment in %s minutes" min-to-app) ; Title
   (format "%s" msg)))                             ; Message/detail text

(defun rh/find-file-cleaned-up (folder)
  "Returns a list of filenames, in a cleaned up format and easy to read. FOLDER will
   be your folder path to search for."
  (interactive)
  (let* ((files (find-lisp-find-files folder ".org$"))
         (files-alist nil)
         (file-names nil))
    (dolist (i files) (push (cons i (capitalize (replace-regexp-in-string "[-_]" " " (replace-regexp-in-string "^[0-9]+-\\|.org$" "" (file-name-nondirectory i))))) files-alist))
    (dolist (i files-alist) (push (cdr i) file-names))
    (let* ((choice (ivy-completing-read "select: " file-names)))
      (find-file (car (rassoc choice files-alist))))))

(defun rh/convert-filename-format (&optional time-p folder-path)
  "Prompts user for filename and directory, and returns the value in a cleaned up format.
   If TIME-P is t, then includes date+time stamp in filename, FOLDER-PATH is the folder
   location to search for files."
  (let* ((file (replace-in-string " " "-" (downcase (read-file-name "select file: " (if folder-path (concat folder-path) org-directory))))))
    (if (file-exists-p file)
        (concat file)
      (if (s-ends-with? ".org" file)
          (concat (format "%s%s" (file-name-directory file) (if time-p (concat (format-time-string "%Y%m%d%H%M%S-") (file-name-nondirectory (downcase file)))
                                                              (concat (file-name-nondirectory (downcase file))))))
        (concat (format "%s%s.org" (file-name-directory file) (if time-p (concat (format-time-string "%Y%m%d%H%M%S-") (file-name-nondirectory (downcase file)))
                                                                (concat (file-name-nondirectory (downcase file))))))))))

(defun rh/find-file-or-create (time-p folder-path &optional type header)
  "Creates a new file, if TYPE is set to NOTE then also insert file-template."
  (interactive)
  (let* ((file (rh/convert-filename-format time-p folder-path))) ;; TODO: Add condition when filename is passed in as argument to skip this piece.
    (if (file-exists-p file)
        (find-file file)
      (when (equal "note" type) (find-file file)
            (insert (format "%s\n%s\n%s\n\n"
                            (downcase (format "#+title: %s" (replace-in-string "-" " " (replace-regexp-in-string "[0-9]+-" "" (replace-in-string ".org" "" (file-name-nondirectory file))))))
                            (downcase (concat "#+author: " user-full-name))
                            (downcase (concat "#+email: " user-mail-address)))))
      (when (equal "project" type) (find-file file)
            (insert (format "%s\n%s\n%s\n\n* Requirements\n\n* Timeframe\n\n* Notes\n\n* Tasks\n"
                            (downcase (format "#+title: %s" (replace-in-string "-" " " (replace-regexp-in-string "[0-9]+-" "" (replace-in-string ".org" "" (file-name-nondirectory file))))))
                            (downcase (concat "#+author: " user-full-name ))
                            (downcase (concat "#+email: " user-mail-address)))))
      (when (equal nil type) (find-file)))
    ;; If user passes in header argument, search for it and if the search fails to find the header, create it.
    (if header (unless (progn (goto-char (point-min)) (re-search-forward (format "^*+ %s" header)))
                 (goto-char (point-max))
                 (newline)
                 (insert (format "* %s" header))
                 (newline)))))
#+end_src
** Archive, keeping Structure
#+begin_src emacs-lisp
(defadvice org-archive-subtree (around fix-hierarchy activate)
  (let* ((fix-archive-p (and (not current-prefix-arg)
                             (not (use-region-p))))
         (location (org-archive--compute-location org-archive-location))
         (afile (car location))
         (offset (if (= 0 (length (cdr location)))
                     1
                   (1+ (string-match "[^*]" (cdr location)))))
         (buffer (or (find-buffer-visiting afile) (find-file-noselect afile))))
    ad-do-it
    (when fix-archive-p
      (with-current-buffer buffer
        (goto-char (point-max))
        (while (> (org-current-level) offset) (org-up-heading-safe))
        (let* ((olpath (org-entry-get (point) "ARCHIVE_OLPATH"))
               (path (and olpath (split-string olpath "/")))
               (level offset)
               tree-text)
          (when olpath
            (org-mark-subtree)
            (setq tree-text (buffer-substring (region-beginning) (region-end)))
            (let (this-command) (org-cut-subtree))
            (goto-char (point-min))
            (save-restriction
              (widen)
              (-each path
                (lambda (heading)
                  (if (re-search-forward
                       (rx-to-string
                        `(: bol (repeat ,level "*") (1+ " ") ,heading)) nil t)
                      (org-narrow-to-subtree)
                    (goto-char (point-max))
                    (unless (looking-at "^")
                      (insert "\n"))
                    (insert (make-string level ?*)
                            " "
                            heading
                            "\n"))
                  (cl-incf level)))
              (widen)
              (org-end-of-subtree t t)
              (org-paste-subtree level tree-text))))))))
#+end_src
* Experiment
#+begin_src emacs-lisp
(setq garbage-collection-messages t)
#+end_src
* Basic configuration
** Personal information
It's useful to have some basic personal information
This is also used by ~GPG~
#+begin_src emacs-lisp
(setq user-full-name "Robert den Harink"
      user-mail-address "robert@robhar.com")
#+end_src
** GPG
Speaking of ~GPG~, I want to use =~/.authsource.gpg= instead of the default in
=~/.emacs.d=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentaly purge this file (I have done
~rm -rf~/.emac.d~ before). I also want to cache as much as possible, as my home
machine is pretty safe, and my laptop is shutdown a lot.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

I use yubikeys for ssh so let's change the ssh auth sock variable
#+begin_src emacs-lisp
(setenv "SSH_AUTH_SOCK" "/Users/robert/.gnupg/S.gpg-agent.ssh")
#+end_src
** Defaults
*** Simple settings
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(display-time-mode 1)                             ; Enable time in the mode-line
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

*** Smooth scrolling
#+begin_src emacs-lisp
;; Vertical Scroll
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq fast-but-imprecise-scrolling nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
#+end_src
*** Auto-customisation
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
** Doom
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       (company +childframe) ; the ultimate code completion backend
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy
        +fuzzy
        +prescient
        +icons)               ; a search engine for love and life
       ;;selectrum

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       ;;doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       (emoji +unicode)  ; 🙂
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
                                        ;minimap           ; show a map of the code on the side
       (modeline)        ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim

       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       treemacs          ; a project drawer, like neotree but cooler
       tree-sitter       ; Modern syntax highlighting
       ;;unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       ;;vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       format            ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       spell             ; tasing you for misspelling mispelling
       grammar           ; tasing grammar mistake every you make

       :tools
       ansible
       debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       lsp
       (magit +forge)             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       rgb               ; creating color strings
       taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;cc                ; C/C++/Obj-C madness
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       json              ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       javascript        ; all(hope(abandon(ye(who(enter(here))))))
       julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ledger            ; an accounting system in Emacs
       lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org +noter +roam +pomodoro +dragndrop +pandoc +present +gnuplot)
       (php +lsp)               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       ;;python            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       rest              ; Emacs as a REST client
       reason
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       (rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       web               ; the tubes
       yaml              ; JSON, but readable

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       literate
       (default +bindings +smartparens))
#+end_src

*** Visual Settings
**** Font Face
#+begin_src emacs-lisp
(setq inhibit-compacting-font-caches t)
(setq doom-font (font-spec :family "Operator Mono Lig" :size 14 :weight: 'book)
      doom-big-font (font-spec :family "JetBrains Mono" :size 18)
      doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size 16)
      doom-serif-font (font-spec :family "IBM Plex Sans" :weight 'light))

(after! org (set-popup-rule! "^\\*lsp-help" :side 'bottom :size .30 :select t)
  (set-popup-rule! "*helm*" :side 'right :size .30 :select t)
  (set-popup-rule! "*Org QL View:*" :side 'right :size .25 :select t)
  (set-popup-rule! "*Capture*" :side 'left :size .30 :select t)
  (set-popup-rule! "*eww*" :side 'right :size .30 :select t)
  (set-popup-rule! "*CAPTURE-*" :side 'left :size .30 :select t))

(after! org
  (custom-set-faces!
    '(org-level-1 :height 1.15 :inherit outline-1)
    '(org-level-2 :height 1.13 :inherit outline-2)
    '(org-level-3 :height 1.11 :inherit outline-3)
    '(org-level-4 :height 1.09 :inherit outline-4)
    '(org-level-5 :height 1.07 :inherit outline-5)
    '(org-level-6 :height 1.05 :inherit outline-6)
    '(org-level-7 :height 1.03 :inherit outline-7)
    '(org-level-8 :height 1.01 :inherit outline-8)))

(after! org
  (custom-set-faces!
    '(org-document-title :height 1.15)))

(after! org
  (custom-set-faces!
    '(org-meta-line :family "IBM Plex Mono")
    '(org-document-info-keyword :family "IBM Plex Mono")
    '(org-document-info :family "IBM Plex Mono")))
#+end_src

I like a little more line-spacing
#+begin_src emacs-lisp
(setq-default line-spacing 0.19)
#+end_src

Make the mode-line smaller
#+begin_src emacs-lisp
(setq doom-modeline-height 25)
(set-face-attribute 'mode-line nil :height 120)
#+end_src
**** Theme and modeline
#+begin_src emacs-lisp
(setq doom-theme 'kaolin-galaxy)
(delq! t custom-theme-load-path)
#+end_src
However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.
#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src
While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                          (eq buffer-file-coding-system 'utf-8)))))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src
**** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src
** Keybindings
#+begin_src emacs-lisp
(bind-key "<f6>" #'link-hint-copy-link)
(bind-key "<f12>" #'org-cycle-agenda-files)
(bind-key "M-." #'completion-at-point)

(map! :after org
      :map org-mode-map
      :leader
      :prefix ("z" . "orgmode")
      :desc "completion at point" "c" #'completion-at-point
      :desc "Review Fleeting Notes" "r" #'rh/review-fleeting-notes
      :desc "Find File in ORGMODE" "f" #'rh/find-files-orgmode
      :desc" File project" "p" #'rh/find-projects
      :prefix ("s" . "+search")
      :desc "Occur" "." #'occur
      :desc "Outline" "o" #'counsel-outline
      :desc "Counsel ripgrep" "d" #'counsel-rg
      :desc "Swiper All" "@" #'swiper-all
      :prefix ("l" . "+links")
      "." #'org-next-link
      "," #'org-previous-link
      "o" #'org-open-at-point
      "g" #'eos/org-add-ids-to-headlines-in-file)

(map! :after org-agenda
      :map org-agenda-mode-map
      :localleader
      :desc "Filter" "f" #'org-agenda-filter)

(defun rh/find-projects ()
  (interactive)
  (rh/find-file-cleaned-up "~/org/gtd/projects/"))
#+end_src
* Package loading
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
This is where you install packages, by declaring them with the ~package!~
macro, then running ~doom refresh~ on the command line. You'll need to
restart Emacs for your changes to take effect! Or at least, run =M-x doom/reload=.

WARNING: Don't disable core packages listed in ~~/.emacs.d/core/packages.el~.
Doom requires these, and disabling them may have terrible side effects.

*** Packages in MELPA/ELPA/emacsmirror
To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp
(package! some-package)
#+end_src

*** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see [[https://github.com/raxod502/straight.el/issues/279][raxod502/straight.el#279]])
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src
** General packages
*** Window management
#+begin_src emacs-lisp
(package! rotate)

(package! org-web-tools)

;; Themes
(package! chocolate-theme)
(package! kaolin-themes)

;; Orgmode Packages
(package! org-edna)
(package! mixed-pitch)
(package! org-roam-server)
(package! org-appear :recipe (:host github :repo "awth13/org-appear"))
(package! ox-pandoc)

;; Misc Packages
(package! elfeed)
(package! elfeed-org)
(package! ob-mermaid)
(package! mermaid-mode)
(package! ox-twbs)
(package! deadgrep)
(package! graphviz-dot-mode)
(package! find-lisp)
#+end_src
*** Fun
Sometimes one just wants a little fun.
XKCD comics are fun.
#+begin_src emacs-lisp
(package! xkcd)
#+end_src

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp
(package! theme-magic)
#+end_src
*** Improving features
**** ESS
View data frames better with
#+begin_src emacs-lisp
(package! ess-view)
#+end_src
**** Info colours
This makes manual pages nicer to look at :)
Variable pitch fontification + colouring

#+begin_src emacs-lisp
(package! info-colors)
#+end_src
**** Mixed pitch
#+begin_src emacs-lisp
(package! mixed-pitch)
#+end_src
*** SVG-Tags
#+begin_src emacs-lisp
(package! svg-tag-mode)
#+end_src
*** Org-clock-csv
#+begin_src emacs-lisp
(package! org-clock-csv)
#+end_src
*** Org reveal js
#+begin_src emacs-lisp
(package! ox-reveal)
#+end_src
*** Nyan Mode
#+begin_src emacs-lisp
(package! nyan-mode)
#+end_src
*** Company Tabnine
#+begin_src emacs-lisp
(package! company-tabnine)

#+end_src
** Language packages
*** Org Mode
**** Improve agenda/capture
The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp
(package! org-super-agenda)
#+end_src

Similarly ~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp
(package! doct)
#+end_src

Pull in Google calendar
#+begin_src emacs-lisp
;;(package! org-gcal)
#+end_src
**** Bullets
#+begin_src emacs-lisp
(package! org-bullets)
#+end_src

*** Systemd
For editing systemd unit files
#+begin_src emacs-lisp
(package! systemd)
#+end_src
*** Graphviz
Graphviz is a nice method of visualising simple graphs, based on plaintext
=.dot= / =.gv= files.
#+begin_src emacs-lisp
(package! graphviz-dot-mode)
#+end_src
*** PHP
XDebug
#+begin_src emacs-lisp
(package! geben)
#+end_src
*** Nginx
#+begin_src emacs-lisp
(package! nginx-mode)
#+end_src
* Package configuration
** Company
    #+begin_src emacs-lisp
    (after! company
      (setq company-idle-delay 0.3
            company-minimum-prefix-length 3
            company-tooltip-align-annotations t
            company-show-numbers t
            company-require-match 'never))
    #+end_src

    Tabnine
    #+begin_src emacs-lisp
    (use-package company-tabnine
      :defer 1
      :custom
      (company-tabnine-max-num-results 9)
      :hook
      (lsp-after-open . (lambda ()
                          (setq company-tabnine-max-num-results 3)
                          (add-to-list 'company-transformers 'company//sort-by-tabnine t)
                          (add-to-list 'company-backends '(company-capf :with company-tabnine :separate))))
      (kill-emacs . company-tabnine-kill-process)
      :config
      ;; Enable TabNine on default
      (add-to-list 'company-backends #'company-tabnine)

      ;; Integrate company-tabnine with lsp-mode
      (defun company//sort-by-tabnine (candidates)
        (if (or (functionp company-backend)
                (not (and (listp company-backend) (memq 'company-tabnine company-backends))))
            candidates
          (let ((candidates-table (make-hash-table :test #'equal))
                candidates-lsp
                candidates-tabnine)
            (dolist (candidate candidates)
              (if (eq (get-text-property 0 'company-backend candidate)
                      'company-tabnine)
                  (unless (gethash candidate candidates-table)
                    (push candidate candidates-tabnine))
                (push candidate candidates-lsp)
                (puthash candidate t candidates-table)))
            (setq candidates-tabnine (nreverse candidates-tabnine))

            (nconc (seq-take candidates-tabnine 3)
                   (seq-take candidates-lsp 6))))))
    #+end_src

*** Plain Text
    ~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
    #+begin_src emacs-lisp
    (set-company-backend!
      '(text-mode
        markdown-mode
        gfm-mode)
      '(:seperate
        company-ispell
        company-files
        company-yasnippet))
    #+end_src
    We then configure the dictionary we're using in [[*Ispell][Ispell]].
    *** ESS
    ~company-dabbrev-code~ is nice. Let's have it.
    #+begin_src emacs-lisp
    (set-company-backend! 'ess-r-mode '(company-R-args company-R-objects company-dabbrev-code :separate))
    #+end_src
** Deft
When this variable is set to t your deft directory will be updated to your
projectile-project root’s folder when switching projects, and the deft buffer’s
contents will be refreshed.
Configuring DEFT default settings
#+begin_src emacs-lisp
(use-package deft
  :bind (("<f8>" . deft))
  :commands (deft deft-open-file deft-new-file-named)
  :config
  (setq deft-directory "~/org/"
        deft-auto-save-interval 0
        deft-recursive t
        deft-current-sort-method 'title
        deft-extensions '("md" "txt" "org")
        deft-use-filter-string-for-filename t
        deft-use-filename-as-title nil
        deft-markdown-mode-title-level 1
        deft-file-naming-rules '((nospace . "-"))))

(defun my-deft/strip-quotes (str)
  (cond ((string-match "\"\\(.+\\)\"" str) (match-string 1 str))
        ((string-match "'\\(.+\\)'" str) (match-string 1 str))
        (t str)))

(defun my-deft/parse-title-from-front-matter-data (str)
  (if (string-match "^title: \\(.+\\)" str)
      (let* ((title-text (my-deft/strip-quotes (match-string 1 str)))
             (is-draft (string-match "^draft: true" str)))
        (concat (if is-draft "[DRAFT] " "") title-text))))

(defun my-deft/deft-file-relative-directory (filename)
  (file-name-directory (file-relative-name filename deft-directory)))

(defun my-deft/title-prefix-from-file-name (filename)
  (let ((reldir (my-deft/deft-file-relative-directory filename)))
    (if reldir
        (concat (directory-file-name reldir) " > "))))

(defun my-deft/parse-title-with-directory-prepended (orig &rest args)
  (let ((str (nth 1 args))
        (filename (car args)))
    (concat
     (my-deft/title-prefix-from-file-name filename)
     (let ((nondir (file-name-nondirectory filename)))
       (if (or (string-prefix-p "README" nondir)
               (string-suffix-p ".txt" filename))
           nondir
         (if (string-prefix-p "---\n" str)
             (my-deft/parse-title-from-front-matter-data
              (car (split-string (substring str 4) "\n---\n")))
           (apply orig args)))))))

(provide 'my-deft-title)

(advice-add 'deft-parse-title :around #'my-deft/parse-title-with-directory-prepended)
#+end_src
** Evil
 I don’t use ~evil-escape-mode~, so I may as well turn it off, I’ve heard it
 contributes a typing delay. I’m not sure it’s much, but it is an extra
 pre-command-hook that I don’t benefit from, so…
#+begin_src emacs-lisp
;; (after! evil-escape (evil-escape-mode -1))
#+end_src

When I want to make a substitution, I want it to be global more often than not —
so let’s make that the default. 
#+begin_src emacs-lisp
(after! evil (setq evil-ex-substitute-global t))
#+end_src
** ISpell
*** Downloading dictionaries
Let's get a nice big dictionary from [[http://app.aspell.net/create][SCOWL Custom List/Dictionary Creator]] with
the following configuration
- size :: 80 (huge)
- spellings :: British(-ise) and Australian
- spelling variants level :: 0
- diacritics :: keep
- extra lists :: hacker, roman numerals
  *** Hunspell
#+begin_src shell :tangle (if (file-exists-p "/usr/local/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=US&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"

mv en-custom.{aff,dic} /usr/local/share/myspell/
#+end_src
**** Aspell
#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && make install
#+end_src
*** Configuration
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src
Oh, and by the way, if ~company-ispell-dictionary~ is ~nil~, then
~ispell-complete-word-dict~ is used instead, which once again when ~nil~ is
~ispell-alternate-dictionary~, which at the moment maps to a plaintext version of
the above.

It seems reasonable to want to keep an eye on my personal dict, let's have it
nearby (also means that if I change the 'main' dictionary I keep my addition).
#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src
** Pandoc
#+begin_src
(setq org-pandoc-options '((standalone . t) (self-contained . t)))
#+end_src
** Treemacs
#+begin_src emacs-lisp
(use-package! treemacs-magit
  :defer t
  :after (treemacs magit))
#+end_src
* Language configuration
** General
*** File Templates
    For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
    need to have a template assigned.
    #+begin_src emacs-lisp
    (set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
    (set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
    (set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
    #+end_src

** Latex
#+begin_src emacs-lisp
(use-package ox-latex)
#+end_src
** PHP Mode
    PHP Mode configuration
    #+BEGIN_SRC emacs-lisp
    (use-package php-mode
    ;;
    :init
    (setq phpactor-executable "/usr/local/bin/phpactor")
    :hook ((php-mode . (lambda () (set (make-local-variable 'company-backends)
                                        '(;; list of backends
                                        company-phpactor
                                        company-files
                                        ))))))
    #+END_SRC
** Nginx
#+begin_src emacs-lisp
(use-package nginx-mode)
#+end_src
** Rust
    #+BEGIN_SRC emacs-lisp
    (use-package lsp-rust
        :after lsp-mode
        :init
        (setq rustic-lsp-server 'rust-analyzer)
        (setq lsp-rust-server 'rust-analyzer))

    (after! rustic-mode (setq rustic-lsp-server 'rust-analyzer))
    #+END_SRC
** Typescript
    #+BEGIN_SRC emacs-lisp
    (defun setup-tide-mode ()
      (interactive)
      (tide-setup)
      (flycheck-mode +1)
      (setq flycheck-check-syntax-automatically '(save mode-enabled))
      (setq company-tooltip-align-annotations t)
      (setq tide-completion-detailed nil)
      (eldoc-mode +1)
      (tide-hl-identifier-mode +1)
      ;; enable eslint
      (setq flycheck-checker 'javascript-eslint)
      (flycheck-add-mode 'javascript-eslint 'web-mode)
      ;; enable typescript-tslint checker
      (company-mode +1))

    ;; aligns annotation to the right hand side
    (use-package tide
      :after (typescript-mode company flycheck)
      :hook ((typescript-mode . tide-setup)
             (typescript-mode . tide-hl-identifier-mode)))

    (add-hook 'typescript-mode-hook #'setup-tide-mode)

    (require 'web-mode)
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
    (add-hook 'web-mode-hook
              (lambda ()
                (when (string-equal "tsx" (file-name-extension buffer-file-name))
                  (setup-tide-mode))))
    #+END_SRC
** Orgmode
Fix: https://github.com/hlissner/doom-emacs/issues/3172
#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda () (electric-indent-local-mode -1)))
#+end_src

Lets define the files/directories for orgmode
#+begin_src emacs-lisp
(let ((default-directory "~/org/"))
  (setq rh-org-gtd-path (expand-file-name "gtd/"))
  (setq rh-org-notes-path (expand-file-name "notes.org"))
  (setq rh-org-todo-path (expand-file-name "gtd/tasks.org"))
  (setq rh-org-journal-path (expand-file-name "journal.org")))
#+end_src

Here we add any requirements before org-mode starts to load.
#+begin_src emacs-lisp
(use-package! find-lisp)
(require 'org-habit)
(require 'org-id)
(require 'org-checklist)
(setq org-pretty-entities t)
(after! org (setq
             org-link-file-path-type 'relative
             org-log-state-notes-insert-after-drawers t
             org-catch-invisible-edits 'error
             org-archive-subtree-add-inherited-tags t
             org-refile-targets '((nil :maxlevel . 9)
                                  (org-agenda-files :maxlevel . 4))
             org-refile-use-outline-path 'buffer-name
             org-outline-path-complete-in-steps nil
             org-refile-allow-creating-parent-nodes 'confirm
             org-startup-indented 'indent
             org-insert-heading-respect-content t
             org-startup-folded 'content
             org-src-tab-acts-natively t
             org-list-allow-alphabetical nil))

(add-hook 'org-mode-hook 'auto-fill-mode)
(setq org-attach-directory (concat org-directory ".attach/"))
#+end_src

*** Agenda
First we setup a few defaults for the org-agenda buffer:
#+begin_src emacs-lisp
(setq org-agenda-todo-ignore-scheduled nil
      org-agenda-tags-todo-honor-ignore-options t
      org-agenda-start-with-log-mode '(clock)
      org-agenda-start-with-clockreport-mode t
      org-agenda-start-day nil ;; start on today
      org-agenda-fontify-priorities t)
#+end_src

Show effort in agenda items
#+begin_src emacs-lisp
(setq org-agenda-prefix-format '((agenda . " %i %-12t %-6e % s")
                                 (todo . " %i %-12:c %-12e")
                                 (tags . " %i %-12:c")
                                 (search . " %i %-12:c")))

#+end_src

Use super agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))
(after! org-agenda
  (org-super-agenda-mode))

;; header key map breaks evil navigation
(setq org-super-agenda-header-map (make-sparse-keymap))
#+end_src

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span '1)
                      (org-super-agenda-groups
                       '((:name " Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :habit t
                          :order 1)
                         (:discard (:anything))))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "◴ Overdue"
                           :deadline past
                           :scheduled past
                           :order 10)
                          (:discard (:todo "SOMEDAY"))
                          (:name " On Hold"
                           :and (:todo "HOLD" :not (:tag "@delegated"))
                           :order 15)
                          (:name " Next Tasks"
                           :and (:todo "NEXT" :not (:tag "@delegated"))
                           :order 20)
                          (:name "@ Delegated"
                           :tag "@delegated"
                           :order 40)
                          (:name " Read"
                           :tag ("@read")
                           :order 60)
                          (:name " Fix"
                           :and (:tag "@fix" :not (:todo "SOMEDAY"))
                           :order 70)
                          (:name "Projects"
                           :children t
                           :order 75)
                          (:discard (:scheduled t :deadline t))
                          (:name "? Other"
                           :auto-category t
                           :order 80)
                          ))))
          ))))
#+end_src
*** Notifications
Show native notifications using ~alerter~ on MacOS.
#+begin_src emacs-lisp
(after! org
  (setq appt-time-msg-list nil)    ;; clear existing appt list
  (setq appt-display-interval '5)  ;; warn every 5 minutes from t - appt-message-warning-time
  (setq
   appt-message-warning-time '15  ;; send first warning 15 minutes before appointment
   appt-display-mode-line nil     ;; don't show in the modeline
   appt-display-format 'window)   ;; pass warnings to the designated window function
  (setq appt-disp-window-function (function rh/appt-display-native))
  (appt-activate 1)
  (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
  (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly
  (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt))
#+end_src
*** Capture templates
What templates do I need available for quick capture of information?
 - Checklists
 - Journal
 - Notes
 - Web Resources

Task items can be a few different things, and there’s the whole GTD which i’m
trying my bestest to follow. Sometimes I may have a task item that I simply need
to remind myself to complete, and just need to check it off a list acknowledging
i’ve completed it and other times I need an actual task item to capture and
track data in.

#+begin_src emacs-lisp
;; This function is used in conjuction with the capture template "new note" which will find or generate a note based off the folder and filename.
(defun rh/create-notes-file ()
  "Function for creating a notes file under org-capture-templates."
  (rh/find-file-or-create t "~/org/references/" "note"))

(defun rh/create-roam-file ()
  "Function to create a new roam notes file, while prompting for folder location."
  (rh/find-file-or-create t org-directory "note"))

(defun rh/find-project-task ()
  "Function for creating a project file under org-capture-templates."
  (rh/find-file-or-create t "~/org/gtd/projects" "project" "Tasks")
  (setq org-agenda-files (append (file-expand-wildcards "~/org/gtd/*.org") (file-expand-wildcards "~/org/gtd/*/*.org"))))

(defun rh/find-project-timeframe ()
  "Function for creating a project file under org-capture-templates."
  (rh/find-file-or-create t "~/org/gtd/projects" "project" "Timeframe"))

(defun rh/find-project-requirement ()
  "Function for creating a project file under org-capture-templates."
  (rh/find-file-or-create t "~/org/gtd/projects" "project" "Requirements"))

(defun rh/find-project-note ()
  "Function for creating a project file under org-capture-templates."
  (rh/find-file-or-create t "~/org/gtd/projects" "project" "Notes"))

(defun rh/return-headline-in-file ()
  "Returns the headline position."
  (let* ((org-agenda-files "~/org/elfeed.org")
         (location (nth 3 (org-refile-get-location nil nil 'confirm))))
    (goto-char location)
    (org-end-of-line)))

(defun rh/find-project-todo ()
  "When in projectile path, finds root todo.org file"
  (let ((path (doom-project-root))
        (file "todo.org"))
    (find-file (format "%s%s" path file))))

(defun rh/enter-headline-websources ()
  "This is a simple function for the purposes when using org-capture to add my entries to a custom Headline, and if URL is not in clipboard it'll return an error and cancel the capture process."
  (let* ((file "~/org/gtd/websources.org")
         (headline (read-string "Headline? ")))
    (progn
      (rh/check-headline-exist file headline)
      (goto-char (point-min))
      (re-search-forward (format "^\*+\s%s" (upcase headline))))))

(defun rh/check-headline-exist (file-arg headline-arg)
  "This function will check if HEADLINE-ARG exists in FILE-ARG, and if not it creates the headline."
  (save-excursion (find-file file-arg) (goto-char (point-min))
                  (unless (re-search-forward (format "* %s" (upcase headline-arg)) nil t)
                    (goto-char (point-max)) (insert (format "* %s" (upcase headline-arg))) (org-set-property "CATEGORY" (downcase headline-arg)))) t)

(defun rh/org-capture-log ()
  "Initiate the capture system and find headline to capture under."
  (let* ((org-agenda-files (find-lisp-find-files "~/org/gtd/" "\.org$"))
         (dest (org-refile-get-location))
         (file (cadr dest))
         (pos (nth 3 dest))
         (title (nth 2 dest)))
    (find-file file)
    (goto-char pos)
    (rh/org-end-of-headline)))
#+end_src

#+begin_src emacs-lisp
(use-package! doct
  :commands (doct))

(setq org-capture-templates
      (doct `(
              ("Task"
               :keys "t"
               :file rh-org-todo-path
               :prepend t
               :headline "Inbox"
               :type entry
               :template "* TODO %^{task}%? %^G")
              ("Review"
               :keys "r"
               :children (("Daily"
                           :keys "d"
                           :headline "Daily Reviews"
                           :type entry
                           :datetree t
                           :file "~/org/gtd/log.org"
                           :template-file "~/org/templates/dailyreview.org")
                          ("Monthly"
                           :keys "m"
                           :headline "Monthly Reviews"
                           :type entry
                           :datetree t
                           :file "~/org/gtd/log.org"
                           :template-file "~/org/templates/monthlyreview.org")
                          ("Finanaces"
                           :keys "f"
                           :type entry
                           :headline "Finances"
                           :datetree t
                           :file "~/org/gtd/log.org"
                           :template-file "~/org/templates/finances.org")
                          ))
              ("Projects"
               :keys "p"
               :children (("Task"
                           :keys "t"
                           :headline "Tasks"
                           :function rh/find-project-task
                           :template "* TODO %^{task}%? %^G")
                          ("Issue"
                           :keys "i"
                           :headline "Tasks"
                           :function rh/find-project-task
                           :template "* TODO %^{Ticket} %^{task}%? %^G")
                          ("Meeting"
                           :keys "m"
                           :headline "Tasks"
                           :clock-in t
                           :function rh/find-project-task
                           :template "* TODO Meeting with %? :Meeting:")
                          ))
              )))
#+end_src

*** Clock Settings
#+begin_src emacs-lisp
(after! org (setq
             org-clock-idle-time nil
             org-clock-continuously t
             org-clock-persist-query-resume nil
             org-clock-auto-clock-resolution (quote when-no-clock-is-running)
             org-clock-out-remove-zero-time-clocks t
             org-clock-persist t
             org-clock-in-resume nil
             org-clock-in-switch-to-state "HOLD"
             org-clock-report-include-clocking-task t
             org-clock-out-remove-zero-time-clocks t
             org-clock-history-length 23
             org-clock-into-drawer t
             org-duration-format 'h:mm
             org-agenda-clock-consistency-checks (quote (:max-duration "4:00"
                                                         :min-duration 0
                                                         :max-gap 0
                                                         :gap-ok-around ("4:00")))
             ))
#+end_src

*** Default tags
I like to keep a list of predefined context tags, this helps speed the
assignment process up and also keep things consistent.
#+begin_src emacs-lisp
(setq org-tag-alist '(
                      ;; Depth
                      ("@immersive" . ?i) ;; "Deep"
                      ("@depthless" . ?p) ;; "Boring"
                      ;; Context
                      ("@work" . ?w)
                      ("@fix" . ?f) ; stuff that needs physical fixing
                      ("@home" . ?h)
                      ("@errand" . ?e)
                      ("@delegated" . ?d)
                      ("@read" . ?r)
                      ("@project" . ?p)
                      ;; Energy
                      ("Challenge" . ?1)
                      ("Average" . ?2)
                      ("Easy" . ?3)
                      ;; Billing
                      ("Billable" . ?+)
                      ("NonBillable" . ?-)
                      ("Billed" . ?$)
                      ;; Categories
                      ("Fin" . ?f) ; stocks, investment, admin
                      ("Biz" . ?b) ; sales, marketing, supplier management, managing user feedback, metrics and analytics
                      ("Dev" . ?d) ; coding, prototyping, wire framing, operations, bug investigation and bug fixing
                      ("Hiring" . ?h) ; reading CVs, interviews, contracts, meet-ups, dealing with recruiters
                      ("Inbox" . ?i) ; keeping up with email and notifications
                      ("Manage" . ?m) ; personal planning, sprint planning, training devs, 1:1s, equipment, code review, retrospectives
                      ("Meeting" . ?c) ; scheduled meetings and calls
                      ("QA" . ?q) ; manual testing
                      ("Research" . ?r) ; research, reading papers, experimenting
                      ))
#+end_src
*** Export settings
#+begin_src emacs-lisp
(after! org (setq org-html-head-include-scripts t
                  org-export-with-toc t
                  org-export-with-author t
                  org-export-headline-levels 4
                  org-export-with-drawers nil
                  org-export-with-email t
                  org-export-with-footnotes t
                  org-export-with-sub-superscripts nil
                  org-export-with-latex t
                  org-export-with-section-numbers nil
                  org-export-with-properties nil
                  org-export-with-smart-quotes t
                  org-export-backends '(pdf ascii html latex odt md pandoc)))
#+end_src

Embed images into the exported HTML files.
#+begin_src emacs-lisp
(defun replace-in-string (what with in)
  (replace-regexp-in-string (regexp-quote what) with in nil 'literal))

(defun org-html--format-image (source attributes info)
  (progn
    (setq source (replace-in-string "%20" " " source))
    (format "<img src=\"data:image/%s;base64,%s\"%s />"
            (or (file-name-extension source) "")
            (base64-encode-string
             (with-temp-buffer
               (insert-file-contents-literally source)
              (buffer-string)))
            (file-name-nondirectory source))))
#+end_src
*** Journal
#+begin_src emacs-lisp
(after! org (setq org-journal-dir "~/org/gtd/journal/"
                  org-journal-enable-agenda-integration t
                  org-journal-file-type 'monthly
                  org-journal-carryover-items "TODO=\"TODO\"|TODO=\"NEXT\"|TODO=\"PROJ\"|TODO=\"STRT\"|TODO=\"WAIT\"|TODO=\"HOLD\""))
#+end_src
*** Keywords
After much feedback and discussing with other users, I decided to simplify the
keyword list to make it simple. Defining a project will now focus on the tag
word :project: so that all child task are treated as part of the project.

| Keyword | Description                                                  |
|---------+--------------------------------------------------------------|
| TODO    | Task has actionable items defined and ready to be worked.    |
| HOLD    | Has actionable items, but is on hold due to various reasons. |
| NEXT    | Is ready to be worked and should be worked on soon.          |
| DONE    | Task is completed and closed.                                |
| KILL    | Abandoned or terminated.                                     |

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "SOMEDAY(s)"  ; A task I want to do.
         "TODO(t)"  ; A task that needs doing & is ready to do.
         "HOLD(h)" ; Task is in progress and being worked.
         "NEXT(n)" ; Task items that are ready to be worked.
         "|"
         "DONE(x!)"  ; Task successfully completed.
         "KILL(k@)")) ; Task was cancelled, aborted or is no longer applicable.
      org-todo-keyword-faces
      '(("TODO" . (:foreground "#42F5A9" :weight bold))
        ("SOMEDAY" . (:foreground "#DCFFBF" :weight bold))
        ("NEXT" . (:foreground "#F54261" :weight bold))
        ("HOLD" . (:foreground "#FF9644" :weight bold))
        ("DONE" . (:foreground "#5F5F6E" :weight bold))
        ("KILL" . (:foreground "#4D4D5E" :italic t))))
#+end_src
*** Loading agenda settings
#+begin_src emacs-lisp
(after! org (setq org-agenda-diary-file "~/org/diary.org"
                  org-agenda-dim-blocked-tasks nil ; This has funny behavior, similar to checkbox dependencies.
                  org-agenda-start-on-weekday nil
                  org-agenda-use-time-grid t
                  org-agenda-tags-column 9
                  org-agenda-hide-tags-regexp "^w+" ; Hides tags in agenda-view
                  org-agenda-compact-blocks nil
                  org-agenda-block-separator ""
                  org-agenda-skip-scheduled-if-done t
                  org-agenda-skip-deadline-if-done t
                  org-agenda-window-setup 'current-window
                  org-enforce-todo-checkbox-dependencies nil ; This has funny behavior, when t and you try changing a value on the parent task, it can lead to Emacs freezing up. TODO See if we can fix the freezing behavior when making changes in org-agenda-mode.
                  org-enforce-todo-dependencies t
                  org-habit-show-habits t))

(after! org (setq org-agenda-files (append (file-expand-wildcards "~/org/gtd/*.org") (file-expand-wildcards "~/org/gtd/*/*.org"))))
#+end_src

*** Logging and drawers
Next, we like to keep a history of our activity of a task so we track when
changes occur, and we also keep our notes logged in their own drawer. Optionally
you can also add the following in-buffer settings to override the
org-log-into-drawer function. #+STARTUP: logdrawer or #+STARTUP: nologdrawer
#+begin_src emacs-lisp
(after! org (setq org-log-into-drawer t
                  org-log-done 'time
                  org-log-repeat 'time
                  org-log-redeadline 'note
                  org-log-reschedule 'note))
#+end_src
*** Looks and feels
Here we change some of the things how org-mode looks and feels, some options available are:
#+begin_src emacs-lisp
(after! org (setq org-hide-emphasis-markers t
                  org-hide-leading-stars t))
#+end_src

Org bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :custom
  (org-bullets-bullet-list '("⊗" "⊖" "⊘" "◐" "◑" "◒" "◓" "◴" "◵" "◶" "◷" "⚆" "⚇" "⚈" "⚉" "♁"))
  (org-ellipsis "⤵")
  :hook (org-mode . org-bullets-mode))
#+end_src

Custom faces
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(org-block                 ((t (:inherit fixed-pitch))))
 '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
 '(org-property-value        ((t (:inherit fixed-pitch))) t)
 '(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold))))
 '(org-verbatim              ((t (:inherit (shadow fixed-pitch))))))
#+end_src
*** Properties
I like to have properties inherited from their parent.
#+begin_src emacs-lisp
(after! org (setq org-use-property-inheritance t))
#+end_src
*** Reveal
#+begin_src emacs-lisp
(use-package! ox-reveal)
(setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
#+end_src
*** ROAM
#+begin_src emacs-lisp
(when (require 'org-roam nil 'noerror)
  (setq org-roam-tag-sources '(prop last-directory))
  (setq org-roam-db-location "~/org/roam.db")
  (setq org-roam-directory "~/org/roam")
  (setq org-roam-buffer-position 'right)
  (setq org-roam-link-file-path-type 'absolute)
  (setq org-roam-file-exclude-regexp "references/*\\|gtd/*\\|elfeed.org\\|README.org\\|templates/*")
  (setq org-roam-completion-everywhere t)
  ;; Configuration of daily templates
  (push '("x" "Projects" plain (function org-roam-capture--get-point)
          :file-name "gtd/projects/%<%Y%m%d%H%M>-${slug}"
          :head "#+title: ${title}\n#+roam_tags: %^{tags}\n\n%?"
          :unnarrowed t) org-roam-capture-templates))
#+end_src

#+begin_src emacs-lisp
(when (require 'org-roam-server nil 'noerror)
  (use-package org-roam-server
    :ensure t
    :config
    (setq org-roam-server-host "127.0.0.1"
          org-roam-server-port 8070
          org-roam-server-export-inline-images t
          org-roam-server-authenticate nil
          org-roam-server-network-poll t
          org-roam-server-network-vis-options "{ \"layout\": { \"randomSeed\": false }, \"physics\": { \"stabilization\": { \"iterations\": 10000, \"fit\": false, \"updateInterval\": 10000 }, \"barnesHut\": { \"gravitationalConstant\": -4000, \"avoidOverlap\": 1, \"springConstant\": 0.02, \"springLength\": 95 } } }"
          org-roam-server-network-arrows nil
          org-roam-server-serve-files t
          org-roam-server-extra-node-options (list (cons 'shape "dot") (cons 'opacity 1))
          org-roam-server-network-label-truncate t
          org-roam-server-network-label-truncate-length 40
          org-roam-server-network-label-wrap-length 20)))
#+end_src
*** Module settings
~Org-Appear~ is a cool package that’ll auto show emphasis markers when your cursor
is on a element enclosed in emphasis.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-appear-mode)
#+end_src
